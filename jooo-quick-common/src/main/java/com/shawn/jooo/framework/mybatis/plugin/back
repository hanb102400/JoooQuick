package com.shawn.jooo.framework.mybatis.plugin;


import com.shawn.jooo.framework.mybatis.dialect.Dialect;
import com.shawn.jooo.framework.mybatis.dialect.DialectFactory;
import com.shawn.jooo.framework.core.page.Pageable;
import org.apache.commons.lang3.StringUtils;
import org.apache.ibatis.cache.CacheKey;
import org.apache.ibatis.executor.Executor;
import org.apache.ibatis.executor.parameter.ParameterHandler;
import org.apache.ibatis.mapping.*;
import org.apache.ibatis.plugin.*;
import org.apache.ibatis.scripting.defaults.DefaultParameterHandler;
import org.apache.ibatis.session.ResultHandler;
import org.apache.ibatis.session.RowBounds;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.Properties;

/**
 * Mybatis分页插件
 *
 * @author shawn
 */
@Intercepts({
        @Signature(type = Executor.class, method = "query", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}),
        // @Signature(type = Executor.class, method = "query", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class}),
})
public class MybatisPaginationPlugin implements Interceptor {

    private static final Logger logger = LoggerFactory.getLogger(MybatisPaginationPlugin.class);

    private Dialect dialect;

    public MybatisPaginationPlugin() {
    }


    @Override
    public Object plugin(Object o) {
        return Plugin.wrap(o, this);
    }

    /**
     * Mybatis拦截器方法，拦截Page,RowBounds参数
     *
     * @param invocation
     * @return
     * @throws Throwable
     */
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        Executor executor = (Executor) invocation.getTarget();
        Object[] args = invocation.getArgs();
        MappedStatement mappedStatement = (MappedStatement) args[0];
        Object parameterObject = args[1];
        RowBounds rowBounds = (RowBounds) args[2];
        ResultHandler resultHandler = (ResultHandler) args[3];
        CacheKey cacheKey = null;
        BoundSql boundSql = null;
        if (args.length == 6) {
            cacheKey = (CacheKey) args[4];
            boundSql = (BoundSql) args[5];
        } else {
            boundSql = mappedStatement.getBoundSql(parameterObject);
            cacheKey = executor.createCacheKey(mappedStatement, parameterObject, rowBounds, boundSql);
        }

        //开始分页
        String originalSql = boundSql.getSql().trim();

        //判断是否默认分页参数，则不进行分页
        if (rowBounds == null || rowBounds == RowBounds.DEFAULT) {
            return invocation.proceed();
        }

        // 判断分页参数：Pageable类型参数
        if (rowBounds instanceof Pageable) {
            Pageable pageable = (Pageable) rowBounds;
            final String countSql = this.dialect.buildCountSql(originalSql);
            //构建并执行查询总数sql
            Long totalCount = getTotalCount(mappedStatement, parameterObject, boundSql, countSql);
            pageable.setTotalCount(totalCount);
        }

        //构建并分页sql
        String pagingSql = dialect.buildPaginationSql(originalSql, rowBounds.getOffset(), rowBounds.getLimit());

        //配置分页SQL,并重置rowBounds
        invocation.getArgs()[0] = buildMappedStatement(mappedStatement, parameterObject, boundSql, pagingSql);
        invocation.getArgs()[2] = RowBounds.DEFAULT;
        return invocation.proceed();
    }


    private MappedStatement buildMappedStatement(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql, String newSql) {
        SqlSource sqlSource = bulidSqlSource(mappedStatement, parameterObject, boundSql, newSql);
        MappedStatement.Builder builder = new MappedStatement.Builder(
                mappedStatement.getConfiguration(),
                mappedStatement.getId(),
                sqlSource,
                mappedStatement.getSqlCommandType());

        builder.databaseId(mappedStatement.getDatabaseId());
        builder.parameterMap(mappedStatement.getParameterMap());
        builder.resource(mappedStatement.getResource());
        builder.resultMaps(mappedStatement.getResultMaps());
        builder.fetchSize(mappedStatement.getFetchSize());
        builder.timeout(mappedStatement.getTimeout());
        builder.statementType(mappedStatement.getStatementType());
        builder.resultOrdered(mappedStatement.isResultOrdered());
        builder.keyGenerator(mappedStatement.getKeyGenerator());
        builder.resultSetType(mappedStatement.getResultSetType());
        builder.useCache(mappedStatement.isUseCache());
        builder.cache(mappedStatement.getCache());
        builder.flushCacheRequired(mappedStatement.isFlushCacheRequired());


        String KeyProperties = StringUtils.join(mappedStatement.getKeyProperties(), ",");
        builder.keyProperty(KeyProperties);
        String keyColumns = StringUtils.join(mappedStatement.getKeyColumns(), ",");
        builder.keyColumn(keyColumns);


        return builder.build();
    }

    private SqlSource bulidSqlSource(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql, String newSql) {
        return new SqlSource() {
            @Override
            public BoundSql getBoundSql(Object o) {
                return buildBoundSql(mappedStatement, parameterObject, boundSql, newSql);
            }
        };
    }

    /**
     * 构建BoundSql
     *
     * @param mappedStatement
     * @param parameterObject
     * @param boundSql
     * @param newSql
     * @return
     */
    private BoundSql buildBoundSql(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql, String newSql) {
        BoundSql newBoundSql = new BoundSql(mappedStatement.getConfiguration(), newSql, boundSql.getParameterMappings(), parameterObject);
        for (ParameterMapping mapping : boundSql.getParameterMappings()) {
            String prop = mapping.getProperty();
            if (boundSql.hasAdditionalParameter(prop)) {
                newBoundSql.setAdditionalParameter(prop, boundSql.getAdditionalParameter(prop));
            }
        }
        return newBoundSql;
    }

    /**
     * 获取总记录数量
     *
     * @param totalCountSql
     * @param mappedStatement
     * @param parameterObject
     * @param boundSql
     * @return
     * @throws SQLException
     */
    public Long getTotalCount(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql, String totalCountSql) throws SQLException {
        Environment environment = mappedStatement.getConfiguration().getEnvironment();
        Connection connection = environment.getDataSource().getConnection();
        PreparedStatement preparedStatement = null;
        ResultSet rs = null;
        try {
            preparedStatement = connection.prepareStatement(totalCountSql);
            ParameterHandler parameterHandler = new DefaultParameterHandler(mappedStatement, parameterObject, boundSql);
            parameterHandler.setParameters(preparedStatement);
            rs = preparedStatement.executeQuery();
            if (rs.next()) {
                return rs.getLong(1);
            }
        } catch (SQLException e) {
            logger.error("getTotalCount error",e);
            throw e;
        } finally {
            try {
                if (preparedStatement != null) {
                    rs.close();
                }
                if (preparedStatement != null) {
                    preparedStatement.close();
                }
            } catch (SQLException e) {
                logger.error("getTotalCount error",e);
               throw e;
            }
        }
        return 0L;
    }


    @Override
    public void setProperties(Properties properties) {
        try {
            this.dialect = DialectFactory.getDialect(properties.getProperty("dialect"));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

}
